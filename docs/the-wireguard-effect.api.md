## API Report File for "the-wireguard-effect"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Brand } from 'effect/Brand';
import * as Cause from 'effect/Cause';
import { Duration } from 'effect/Duration';
import * as Effect from 'effect/Effect';
import { Equals } from 'effect/Types';
import * as Option from 'effect/Option';
import * as ParseResult from '@effect/schema/ParseResult';
import * as Platform from '@effect/platform';
import * as ReadonlyArray_2 from 'effect/ReadonlyArray';
import * as Schema from '@effect/schema/Schema';
import * as Scope from 'effect/Scope';
import * as Socket from '@effect/experimental/Socket/Node';

// @alpha
export const Address: Schema.BrandSchema<((string & Brand<"IPv4">) | (string & Brand<"IPv6">)) & Brand<"Address">, string, never>;

// @alpha
export type Address = Schema.Schema.To<typeof Address>;

// @alpha
export const CidrBlock: Schema.Schema<{
    readonly ip: string & Brand<"IPv4">;
    readonly mask: number & Brand<"CidrMask">;
} | {
    readonly ip: string & Brand<"IPv6">;
    readonly mask: number & Brand<"CidrMask">;
}, {
    readonly ip: string;
    readonly mask: number;
} | {
    readonly ip: string;
    readonly mask: number;
} | `${string}/${number}`, never>;

// @alpha
export type CidrBlockFrom = Schema.Schema.From<typeof CidrBlock>;

// @alpha
export type CidrBlockTo = Schema.Schema.To<typeof CidrBlock>;

// @alpha
export const CidrMask: Schema.BrandSchema<number & Brand<"CidrMask">, number, never>;

// @alpha
export type CidrMask = Schema.Schema.To<typeof CidrMask>;

// @alpha
export const Endpoint: Schema.BrandSchema<(({
    readonly ip: string & Brand<"IPv4">;
    readonly port: number & Brand<"Port">;
} & Brand<"IPv4Endpoint">) | ({
    readonly ip: string & Brand<"IPv6">;
    readonly port: number & Brand<"Port">;
} & Brand<"IPv6Endpoint">)) & Brand<"Endpoint">, {
    readonly ip: string;
    readonly port: number;
} | `${string}:${number}` | {
    readonly ip: string;
    readonly port: number;
} | `[${string}]:${number}`, never>;

// @alpha
export type EndpointFrom = Schema.Schema.From<typeof Endpoint>;

// @alpha
export type EndpointTo = Schema.Schema.To<typeof Endpoint>;

// @alpha
export const IPv4: Schema.BrandSchema<string & Brand<"IPv4">, string, never>;

// @alpha
export type IPv4 = Schema.Schema.To<typeof IPv4>;

// @alpha
export const IPv4Endpoint: Schema.BrandSchema<{
    readonly ip: string & Brand<"IPv4">;
    readonly port: number & Brand<"Port">;
} & Brand<"IPv4Endpoint">, {
    readonly ip: string;
    readonly port: number;
} | `${string}:${number}`, never>;

// @alpha
export type IPv4EndpointFrom = Schema.Schema.From<typeof IPv4Endpoint>;

// @alpha
export type IPv4EndpointTo = Schema.Schema.To<typeof IPv4Endpoint>;

// @alpha
export const IPv6: Schema.BrandSchema<string & Brand<"IPv6">, string, never>;

// @alpha
export type IPv6 = Schema.Schema.To<typeof IPv6>;

// @alpha
export const IPv6Endpoint: Schema.BrandSchema<{
    readonly ip: string & Brand<"IPv6">;
    readonly port: number & Brand<"Port">;
} & Brand<"IPv6Endpoint">, {
    readonly ip: string;
    readonly port: number;
} | `[${string}]:${number}`, never>;

// @alpha
export type IPv6EndpointFrom = Schema.Schema.From<typeof IPv6Endpoint>;

// @alpha
export type IPv6EndpointTo = Schema.Schema.To<typeof IPv6Endpoint>;

// @alpha
export const Port: Schema.BrandSchema<number & Brand<"Port">, number, never>;

// @alpha
export type Port = Schema.Schema.To<typeof Port>;

// @alpha
export const SetupData: Schema.BrandSchema<readonly [(({
    readonly ip: string & Brand<"IPv4">;
    readonly port: number & Brand<"Port">;
} & Brand<"IPv4Endpoint">) | ({
    readonly ip: string & Brand<"IPv6">;
    readonly port: number & Brand<"Port">;
} & Brand<"IPv6Endpoint">)) & Brand<"Endpoint">, ((string & Brand<"IPv4">) | (string & Brand<"IPv6">)) & Brand<"Address">] & Brand<"SetupData">, readonly [{
    readonly ip: string;
    readonly port: number;
} | `${string}:${number}` | {
    readonly ip: string;
    readonly port: number;
} | `[${string}]:${number}`, string], never>;

// @alpha
export type SetupDataFrom = Schema.Schema.From<typeof SetupData>;

// @alpha
export type SetupDataTo = Schema.Schema.To<typeof SetupData>;

// Warning: (ae-forgotten-export) The symbol "WireguardConfig_base" needs to be exported by the entry point index.d.ts
//
// @alpha
export class WireguardConfig extends WireguardConfig_base {
    down: (interfaceName: WireguardInterface) => Effect.Effect<void, Platform.Error.PlatformError | WireguardError, Platform.FileSystem.FileSystem>;
    static fromIniConfigFile: (file: string) => Effect.Effect<WireguardConfig, ParseResult.ParseError | Platform.Error.PlatformError, Platform.FileSystem.FileSystem>;
    static fromJsonConfigFile: (file: string) => Effect.Effect<WireguardConfig, ParseResult.ParseError | Platform.Error.PlatformError, Platform.FileSystem.FileSystem>;
    static generateHubSpokeConfigs: (hubData: readonly [{
        readonly ip: string;
        readonly port: number;
    } | `${string}:${number}` | {
        readonly ip: string;
        readonly port: number;
    } | `[${string}]:${number}`, string], spokeData: readonly [readonly [{
        readonly ip: string;
        readonly port: number;
    } | `${string}:${number}` | {
        readonly ip: string;
        readonly port: number;
    } | `[${string}]:${number}`, string], ...(readonly [{
        readonly ip: string;
        readonly port: number;
    } | `${string}:${number}` | {
        readonly ip: string;
        readonly port: number;
    } | `[${string}]:${number}`, string])[]]) => Effect.Effect<[
    hubConfig: WireguardConfig,
    spokeConfigs: ReadonlyArray_2.NonEmptyReadonlyArray<WireguardConfig>
    ], ParseResult.ParseError, never>;
    static generateKeyPair: () => {
        privateKey: WireguardKey;
        publicKey: WireguardKey;
    };
    static generateP2PConfigs: {
        (aliceData: SetupDataFrom, bobEndpoint: SetupDataFrom): Effect.Effect<[aliceConfig: WireguardConfig, bobConfig: WireguardConfig], ParseResult.ParseError, never>;
        (aliceData: SetupDataFrom): (bobData: SetupDataFrom) => Effect.Effect<[aliceConfig: WireguardConfig, bobConfig: WireguardConfig], ParseResult.ParseError, never>;
    };
    up: (interfaceName?: Option.Option<WireguardInterface>) => Effect.Effect<WireguardInterface, WireguardError | Cause.TimeoutException | Socket.SocketError, Platform.FileSystem.FileSystem>;
    upScoped: (interfaceName?: Option.Option<WireguardInterface>) => Effect.Effect<WireguardInterface, WireguardError | Cause.TimeoutException | Socket.SocketError, Scope.Scope | Platform.FileSystem.FileSystem>;
    writeToFile: (file: string) => Effect.Effect<void, ParseResult.ParseError | Platform.Error.PlatformError, Platform.FileSystem.FileSystem>;
}

// Warning: (ae-forgotten-export) The symbol "WireguardError_base" needs to be exported by the entry point index.d.ts
//
// @alpha
export class WireguardError extends WireguardError_base<{
    message: string;
}> {
}

// Warning: (ae-forgotten-export) The symbol "WireguardInterface_base" needs to be exported by the entry point index.d.ts
//
// @alpha
export class WireguardInterface extends WireguardInterface_base {
    applyConfig: (_config: WireguardConfig) => Effect.Effect<void, WireguardError | Socket.SocketError, never>;
    // (undocumented)
    protected static readonly DarwinInterfaceNameRegExp: RegExp;
    down: () => Effect.Effect<void, Platform.Error.PlatformError | WireguardError, Platform.FileSystem.FileSystem>;
    // (undocumented)
    protected static readonly FreeBSDInterfaceNameRegExp: RegExp;
    static getNextAvailableInterface: () => Effect.Effect<WireguardInterface, WireguardError, never>;
    protected static InterfaceRegExpForPlatform: Effect.Effect<RegExp, WireguardError, never>;
    // (undocumented)
    protected static readonly LinuxInterfaceNameRegExp: RegExp;
    // (undocumented)
    protected static readonly OpenBSDInterfaceNameRegExp: RegExp;
    socketLocation: () => string;
    up: (config: WireguardConfig) => Effect.Effect<WireguardInterface, WireguardError | Cause.TimeoutException | Socket.SocketError, Platform.FileSystem.FileSystem>;
    upScoped: (config: WireguardConfig) => Effect.Effect<WireguardInterface, WireguardError | Cause.TimeoutException | Socket.SocketError, Scope.Scope | Platform.FileSystem.FileSystem>;
    // (undocumented)
    protected static readonly WindowsInterfaceNameRegExp: RegExp;
}

// @alpha
export const WireguardKey: Schema.BrandSchema<string & Brand<"WireguardKey">, string, never>;

// @alpha
export type WireguardKey = Schema.Schema.To<typeof WireguardKey>;

// Warning: (ae-forgotten-export) The symbol "WireguardPeer_base" needs to be exported by the entry point index.d.ts
//
// @alpha
export class WireguardPeer extends WireguardPeer_base {
}

// (No @packageDocumentation comment for this package)

```
