{"version":3,"sources":["../../../../actions/connect.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,iBAA4B;AAU5B,gBAA2B;AAE3B,WAAsB;AADtB,YAAY,WAAW;AAMvB,IAAM,oBAAyB,WAAG;AAMlC,IAAM,wBAIK,IAAI,WAAW,QAAG;AACzB,QAAM,YAAY,OAAO,OAAU,aAAa;AAChD,QAAM,qBAA6B,OAAO,OAAU,kBAAkB;AACtE,QAAM,CAAC,EAAE,oBAAoB,IAAY,2BAA2B,oBAAoB,iBAAiB;AACzG,QAAM,sBAAoC,OAAO,WAAW,oBAAoB;AAEhF,MAAI,oBAAoB,UAAU,GAAG;AACjC,WAAO;AAAA,MACI;AAAA,QACH,IAAI;AAAA,UACA,mEAAmE,iBAAiB,kBAAkB,kBAAkB;AAAA,QAC5H;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,CAAC,oBAAoB,CAAC;AAAG,WAAO,OAAS,MAAM,YAAY,CAAC;AAChE,SAAO,oBAAoB,CAAC;AAChC,CAAC,EAAE,KAAY,OAAO,EAAE,OAAO,CAAC,aAAmD,aAAa,OAAU,CAAC,CAAC;AAE5G,IAAM,UAIK,IAAI,WAAW,QAAG;AACzB,QAAM,qBAA6B,OAAO,OAAU,kBAAkB;AAItE,QAAM,aAAiC,mBAAa,MAAM;AAC1D,aAAW,KAAK,CAAC;AACjB,QAAM,eAAiC,OAAO;AAAA,IACnC,QAAQ,MAAW,aAAQ,2BAA2B,EAAE,QAAQ,WAAW,CAAC,CAAC;AAAA,EACxF;AACA,QAAM,gBAAgB,aAAa,aAAkB,eAAU,4BAA4B,EAAE;AAC7F,QAAM,aAAa,GAAG,cAAc,OAAO,IAAI,cAAc,IAAI,IAAI,WAAW,QAAQ,EAAE,IAAI;AAK9F,QAAM,QAAQ,YAAY,MAAM,WAAW,KAAK,KAAK,GAAG,GAAG,IAAI,SAAS,GAAG,GAAM;AAGjF,SAAO;AAAA,IACK,yBAAyB,GAAG,kBAAkB,uBAAuB,iBAAiB,IAAI,UAAU;AAAA,EAChH;AAGA,QAAM,qBAAqB,OAAO,OAAE,qBAAqB;AAGzD,QAAM,OAAO,OAAO,OAAU,2BAA2B,mBAAmB,IAAI,mBAAmB,IAAI,CAAC;AACxG,SAAO,OAAU,eAAe,mBAAmB,IAAI,CAAC;AACxD,EAAW,gBAAK,IAAI;AACpB,QAAM,SAAS,OAAO,OAAS,OAAc,UAAoB,uBAAe,CAAC,EAAE,IAAI,CAAC;AACxF,QAAM,UAAU,GAAG,UAAU,OAAO,UAAU,OAAO,QAAQ,OAAO,OAAO,QAAQ,IAAI,IAAI,OAAO,QAAQ,IAAI;AAG9G,QAAM,MACF,UAAU,OAAO,UACH,WAAW,IAAc,mBAAS,OAAO,CAAC,IAC1C,WAAW,IAAc,mBAAS,OAAO,CAAC;AAC5D,EAAW,qBAAU,mBAAmB,IAAI,CAAC,CAAC;AAK9C,gBAAc,KAAK;AACnB,aAAW,MAAM;AAEjB,SAAO,OAAE,OAAO,GAAG,CAAC;AACpB,SAAO,OAAU,IAAI,wBAAwB,CAAC;AAClD,CAAC,EACI,KAAY,SAAiB,GAAG,CAAC,EACjC,KAAY,UAAkB,GAAG,CAAC;AAEhC,QAAQ,MAAM,OAAO,EAAE,KAAY,QAAqB,oBAAY,KAAK,GAAgB,oBAAY,OAAO","sourcesContent":["import * as GithubArtifacts from \"@actions/artifact\";\nimport * as GithubCore from \"@actions/core\";\nimport * as Platform from \"@effect/platform\";\nimport * as PlatformNode from \"@effect/platform-node\";\nimport * as ParseResult from \"@effect/schema/ParseResult\";\nimport * as Schema from \"@effect/schema/Schema\";\nimport * as Cause from \"effect/Cause\";\nimport * as ConfigError from \"effect/ConfigError\";\nimport * as Console from \"effect/Console\";\nimport * as Effect from \"effect/Effect\";\nimport * as ReadonlyArray from \"effect/ReadonlyArray\";\nimport * as ipAddress from \"ip-address\";\nimport * as dgram from \"node:dgram\";\nimport * as stun from \"stun\";\nimport * as uuid from \"uuid\";\nimport * as Wireguard from \"../src/index.js\";\nimport * as helpers from \"./helpers.js\";\n\nconst client_identifier = uuid.v4();\n\n/**\n * Continuously fetches the connection response artifact for the client until\n * the server has uploaded one.\n */\nconst getConnectionResponse: Effect.Effect<\n    GithubArtifacts.Artifact,\n    Cause.UnknownException | ConfigError.ConfigError,\n    never\n> = Effect.gen(function* (λ) {\n    const artifacts = yield* λ(helpers.listArtifacts);\n    const service_identifier: number = yield* λ(helpers.SERVICE_IDENTIFIER);\n    const [, isConnectionResponse] = helpers.connectionResponseArtifact(service_identifier, client_identifier);\n    const connectionResponses = ReadonlyArray.filter(artifacts, isConnectionResponse);\n\n    if (connectionResponses.length >= 2) {\n        yield* λ(\n            Effect.die(\n                new Error(\n                    `Received more than one connection response artifact for client: ${client_identifier} from service: ${service_identifier}`\n                )\n            )\n        );\n    }\n    if (!connectionResponses[0]) yield* λ(Effect.sleep(\"20 seconds\"));\n    return connectionResponses[0];\n}).pipe(Effect.repeat({ until: (artifact): artifact is GithubArtifacts.Artifact => artifact !== undefined }));\n\nconst program: Effect.Effect<\n    void,\n    ConfigError.ConfigError | Platform.Error.PlatformError | Cause.UnknownException | Error | ParseResult.ParseError,\n    Platform.FileSystem.FileSystem | Platform.Path.Path\n> = Effect.gen(function* (λ) {\n    const service_identifier: number = yield* λ(helpers.SERVICE_IDENTIFIER);\n\n    // We need to know our public ip and port that wireguard will be listening on,\n    // we use stun to get this information.\n    const stunSocket: dgram.Socket = dgram.createSocket(\"udp4\");\n    stunSocket.bind(0);\n    const stunResponse: stun.StunMessage = yield* λ(\n        Effect.promise(() => stun.request(\"stun.l.google.com:19302\", { socket: stunSocket }))\n    );\n    const mappedAddress = stunResponse.getAttribute(stun.constants.STUN_ATTR_XOR_MAPPED_ADDRESS).value;\n    const myLocation = `${mappedAddress.address}:${mappedAddress.port}:${stunSocket.address().port}` as const;\n\n    // Github actions runners are behind stateful NATs, sending a packet into\n    // the void at least every 30 seconds should ensure that the NAT device keeps\n    // the port assignment.\n    const timer = setInterval(() => stunSocket.send(\" \", 0, 1, 80, \"3.3.3.3\"), 10_000);\n\n    // Upload the connection request artifact\n    yield* λ(\n        helpers.uploadSingleFileArtifact(`${service_identifier}_connection-request_${client_identifier}`, myLocation)\n    );\n\n    // Wait for the service to send a connection response artifact\n    const connectionResponse = yield* λ(getConnectionResponse);\n\n    // Process the connection response artifact\n    const data = yield* λ(helpers.downloadSingleFileArtifact(connectionResponse.id, connectionResponse.name));\n    yield* λ(helpers.deleteArtifact(connectionResponse.name));\n    GithubCore.info(data);\n    const config = yield* λ(Schema.decode(Schema.parseJson(Wireguard.WireguardConfig))(data));\n    const address = `${\"ipv4\" in config.Address ? config.Address.ipv4 : config.Address.ipv6}/${config.Address.mask}`;\n\n    // Set the service address\n    const ips =\n        \"ipv4\" in config.Address\n            ? helpers.getRangeV4(new ipAddress.Address4(address))\n            : helpers.getRangeV6(new ipAddress.Address6(address));\n    GithubCore.setOutput(\"service-address\", ips[1]);\n\n    // Stop the stun keepalive and close the socket so that wireguard can bind\n    // to that port now. It needs to be the exact same port as the one we used\n    // for stun otherwise the NAT device might assign a different port.\n    clearInterval(timer);\n    stunSocket.close();\n\n    yield* λ(config.up());\n    yield* λ(Console.log(\"Connection established\"));\n})\n    .pipe(Effect.tapError(Console.log))\n    .pipe(Effect.tapDefect(Console.log));\n\nEffect.suspend(() => program).pipe(Effect.provide(PlatformNode.NodeContext.layer), PlatformNode.NodeRuntime.runMain);\n"]}